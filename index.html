<!DOCTYPE html>
<html>
  <head>
    <title>Introdução</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="shortcut icon" href="assets/img/favicon.ico">
    <link href="assets/css/style.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="assets/css/monokai_sublime.css">
    <script src="assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  </head>
<body>

<p class="img-container"><img src="assets/img/jasmine-logo.png" alt="Jasmine Br"></p>
<p><strong>Tradução da documentação do framework de testes JavaScript Jasmine, versão 2.0.0.</strong></p>
<a name="introdu__o_js"></a><h2>Introdução.js<a class="anchorlink" href="#introdu__o_js"></a></h2>
<p>Jasmine é um framework BDD (behavior-driven development | desenvolvimento orientado a comportamento) para testar código JavaScript. Ele não depende de nenhum outro framework JavaScript. Também não requer DOM, além de ter uma sintaxe limpa e óbvia, então você pode facilmente escrever testes. <a href="http://jasmine.github.io/2.0/introduction.html">Este guia</a> funciona com a versão 2.0.0 do Jasmine.</p>
<pre>
<code>
describe("Um conjunto", function () {
    it("contém uma especulação com uma expectativa", function () {
        expect(true).toBe(true);
    });
});
</code>
</pre>

<a name="distribui__o_independente"></a><h2>Distribuição Independente<a class="anchorlink" href="#distribui__o_independente"></a></h2>
<p>A <a href="https://github.com/pivotal/jasmine/tree/master/dist">distribuição independente</a> contém tudo que você precisa para rodar o Jasmine. Abrir <code>SpecRunner.html</code> irá rodar as especulações incluídas (<code>specs</code>, de agora em diante). Você irá notar que ambos os arquivos fonte e suas respectivas <em>specs</em> serão linkadas no <code>head</code> de <code>SpecRunner.html</code>. Para começar a usar o Jasmine, troque os arquivos em <code>source/spec</code> pelos seus próprios arquivos.</p>
<h2>Conjuntos (suites): <code>describe</code> seus testes</h2>
<p>Um conjunto de testes começa com a chamada da função global do Jasmine <code>describe</code> com dois parâmetros: uma string e uma função. A string é o nome ou título para um conjunto de especulações - geralmente o que está sendo testado. A função é um bloco de código que implementa o conjunto.</p>
<a name="specs__especula__es_"></a><h2>Specs (Especulações)<a class="anchorlink" href="#specs__especula__es_"></a></h2>
<p><em>Especulações</em> são definidas chamando a função global do Jasmine <code>it</code>, que, como <code>describe</code>, pega uma string e uma função. A string é o título da especulação e a função é a especulação, ou o teste. Uma especulação contém uma ou mais expectativas que testam o estado do código. Uma expectativa para o Jasmine é uma asserção, uma afirmação que é ou verdadeira ou falsa. Uma especulação com todas as expectativas verdadeiras é uma especulação aprovada. Uma especulação com uma ou mais expectativas falsas, é uma especulação falha.</p>
<a name="s_o_apenas_fun__es"></a><h3>São apenas funções<a class="anchorlink" href="#s_o_apenas_fun__es"></a></h3>
<p>Sendo os blocos <code>describe</code> e <code>it</code> funções, eles podem conter qualquer código executável necessário para implementar o teste. As <a href="https://github.com/eoop/traduz-ai/blob/master/javascript/003-escopo-de-variavel-js-e-hoisting-explicado.md#escopo-de-vari%C3%A1vel-javascript-e-hoisting-explicado">regras de escopo</a> do JavaScript são aplicadas, então variáveis declaradas em um <code>describe</code> estão disponíveis para qualquer bloco <code>it</code> dentro do conjunto.</p>
<pre>
<code>
describe("Um conjunto é apenas uma função", function () {
    var a;

    it("e isto é uma especulação", function () {
        a = true;

        expect(a).toBe(true);
    });
});
</code>
</pre>

<a name="expectativas"></a><h2>Expectativas<a class="anchorlink" href="#expectativas"></a></h2>
<p>Expectativas são contruídas com a função <code>expect</code> que assume um valor, chamado de atual. Ele é ligado a uma função comparadora, que recebe o valor esperado.</p>
<a name="matchers__comparador_"></a><h2>Matchers (comparador)<a class="anchorlink" href="#matchers__comparador_"></a></h2>
<p>Cada <em>matcher</em> (comparador) implementa uma comparação booleana entre o atual valor e o valor esperado. Ele é responsável por reportar ao Jasmine se a expectativa é verdadeira ou falsa. O Jasmine então vai aprovar ou reprovar a especulação.</p>
<p>Qualquer comparador pode avaliar uma asserção negativa encadeando a chamada <code>expect</code> com um <code>not</code>antes da chamada do comparador.</p>
<pre>
<code>
describe("O comparador 'toBe' compara com ===", function () {

    it("e tem um caso positivo", function () {
        expect(true).toBe(true);
    });

    it("e também um caso negativo", function () {
        expect(false).not.toBe(true);
    });
});
</code>
</pre>

<a name="incluindo_comparadores"></a><h2>Incluindo Comparadores<a class="anchorlink" href="#incluindo_comparadores"></a></h2>
<p>O Jasmine tem um conjunto rico de comparador incluído. Há também a possibilidade de escrever <a href="custom-matcher.html">comparadores personalizados</a>, para quando as afirmações específicas necessárias para as chamadas de seu projeto não estiverem inclusas abaixo.</p>
<pre>
<code>
describe("Comparadores inclusos", function () {

    it("O comparador 'toBe' compara com ===", function () {
        var a = 12;
        var b = a;

        expect(a).toBe(b);
        expect(a).not.toBe(null);
    });

    describe("O comparador 'toEqual' ", function () {

        it("trabalha com simples literais e variáveis", function () {
            var a = 12;
            expect(a).toEqual(12);
        });

        it("pode trabalhar com objetos", function () {
            var foo = {
                a: 12,
                b: 34
            };

            var bar = {
                a: 12,
                b: 34
            };
            expect(foo).toEqual(bar);
        });
    });

    it("O comparador 'toMatch' é para expressões regulares", function () {
        var message = "foo bar baz";

        expect(message).toMatch(/bar/);
        expect(message).toMatch("bar");
        expect(message).not.toMatch(/quux/);
    });

    it("O comparador 'toBeDefined' compara com 'undefined'", function () {
        var a = {
            foo: "foo"
        };

        expect(a.foo).toBeDefined();
        expect(a.bar).not.toBeDefined();
    });

    it("O comparador 'toBeUndefined' compara com 'undefined'", function () {
        var a = {
            foo: "foo"
        };

        expect(a.foo).not.toBeUndefined();
        expect(a.bar).toBeUndefined();
    });

    it("O comparador 'toBeNull' compara com null", function () {
        var a = null;
        var foo = "foo";

        expect(null).toBeNull();
        expect(a).toBeNull();
        expect(foo).not.toBeNull();
    });

    it("O comparador 'toBeTruthy' é para testar o operador booleano", function () {
        var a, foo = "foo";

        expect(foo).toBeTruthy();
        expect(a).not.ToBeTruthy();
    });

    it("O comparador 'toBeFalsy' é para testar o operador booleano", function () {
        var a, foo = "foo";

        expect(a).toBeFalsy();
        expect(foo).not.toBeFalsy();
    });

    it("O comparador 'toContain' é para encontrar um item em um Array", function () {
        var a = ["foo", "bar", "baz"];

        expect(a).toContain("bar");
        expect(a).not.toContain("quux");
    });

    it("O comparador 'toBeLessThan' é para comparações matemáticas", function () {
        var pi = 3.1415926,
            e  = 2.78;

        expect(e).toBeLessThan(pi);
        expect(pi).not.toBeLessThan(e);
    });

    it("O comparador 'toBeGreaterThan' é para comparações matemáticas", function () {
        var pi = 3.1415926,
            e  = 2.78;

        expect(pi).toBeGreaterThan(e);
        expect(e).not.toBeGreaterThan(pi);
    });

    it("O comparador 'toBeCloseTo' é para comparações matemáticas precisas", function () {
        var pi = 3.1415926,
            e  = 2.78;

        expected(pi).not.toBeCloseTo(e, 2);
        expected(pi).toBeCloseTo(e, 0);
    });

    it("O comparador 'toThrow' é para testar se uma função lançou uma exceção", function () {
        var foo = function () {
            return 1 + 2;
        };
        var bar = function () {
            a + 1;
        };

        expect(foo).not.toThrow();
        expect(bar).toThrow();
    });
});
</code>
</pre>

<h2>Agrupamento de Especulações Relacionadas com <code>describe</code></h2>
<p>A função <code>describe</code> é para o agrupamento de especulações relacionadas. O parâmetro string é para nomear a coleção de especulações, e vai ser concatenado com estas para fazer o nome completo da especulação. Isso ajuda a encontrar especulações em um grande conjunto. Se você as nomear bem, suas especulações serão lidas como sentenças tradicionais do estilo <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>.</p>
<pre>
<code>
describe("Uma especulação", function () {
    it("é apenas uma função, então ela pode conter qualquer código", function () {
        var foo = 0;
        foo += 1;

        expect(foo).toEqual(1);
    });

    it("pode ter mais que uma expectativa", function () {
        var foo = 0;
        foo += 1;

        expect(foo).toEqual(1);
        expect(true).toEqual(true);
    });
});
</code>
</pre>

<a name="configura__o_e_subdivis_o"></a><h3>Configuração e Subdivisão<a class="anchorlink" href="#configura__o_e_subdivis_o"></a></h3>
<p>Para ajudar a manter seu conjunto de testes nos padrões DRY (Don&#39;t Repeat Yourself - Não se repita), e então não duplicar seus códigos de configuração e subdivisão, o Jasmine fornece as funções globais <code>beforeEach</code> e <code>afterEach</code>. Como o nome sugere, a função <code>beforeEach</code> é chamada uma vez antes de cada especulação quando <code>describe</code>é rodado, e a função <code>afterEach</code> é chamada depois de cada especulação. Aqui temos o mesmo conjunto de especulações escritas um pouco diferente. A variável em teste é definida no escopo de nível superior - o bloco <code>describe</code> - e o código de inicialização é movido para dentro da função <code>beforeEach</code>. A função <code>afterEach</code> reinicia a variável antes de continuar.</p>
<pre>
<code>
describe("Uma especulação (com configuração e subdivisão)", function () {
    var foo;

    beforeEach(function () {
        foo = 0;
        foo += 1;
    });

    afterEach(function () {
        foo = 0;
    });

    it("é somente uma função, então pode conter qualquer código", function () {
        expect(foo).toEqual(1);
    });

    it("pode ter mais de uma expectativa", function () {
        expect(too).toEqual(1);
        expect(true).toEqual(true);
    });
});
</code>
</pre>

<h3>Aninhando Blocos <code>describe</code></h3>
<p>Chamadas a função <code>describe</code> podem ser aninhadas, com especulações definidas em cada nível. Isto permite a composição de conjuntos como árvores de funções. Antes de uma especulação ser executada, o Jasmine percorre a árvore executando cada função <code>beforeEach</code> na ordem. Depois que a especulação é executada, o Jasmine percore pelas funções <code>afterEach</code> similarmente.</p>
<pre>
<code>
describe("Uma especulação", function () {
    var foo;

    beforeEach(function () {
        foo = 0;
        foo += 1;
    });

    afterEach(function () {
        foo = 0;
    });

    it("é apenas uma função, então pode conter qualquer código", function () {
        expect(foo).toEqual(1);
    });

    it("pode ter mais de uma expectativa", function () {
        expect(foo).toEqual(1);
        expect(true).toEqual(true);
    });

    describe("aninhando um segundo describe", function () {
        var bar;

        beforeEach(function () {
            bar = 1;
        });

        it("se pode referenciar a ambos os escopos se necessário", function () {
            expect(foo).toEqual(bar);
        });
    });
});
</code>
</pre>

<a name="desabilitando_conjuntos"></a><h2>Desabilitando Conjuntos<a class="anchorlink" href="#desabilitando_conjuntos"></a></h2>
<p>Conjuntos e especulações podem ser desabilitados com as funções <code>xdescribe</code> e <code>xit</code>, respectivamente. Estes conjuntos e quaisquer especulações dentro deles serão puladas quando rodar a verificação e seus resultados também não irão aparecer.</p>
<pre>
<code>
xdescribe("Uma especulação", function () {
    var foo;

    beforeEach(function () {
        foo = 0;
        foo += 1;
    });

    it("é apenas uma função, então pode conter qualquer código", function () {
        expect(foo).toEqual(1);
    });
});
</code>
</pre>

<a name="especula__es_pendentes"></a><h2>Especulações Pendentes<a class="anchorlink" href="#especula__es_pendentes"></a></h2>
<p>Especulações Pendentes não rodam, mas seus nomes vão aparecer nos resultados como <code>pending</code>.</p>
<p>Qualquer especulação declarada com <code>xit</code> é marcada como pendente.</p>
<p>Qualquer especulação declarada sem um corpo de função também vai ser marcada como resultado pendente.</p>
<p>E se você chamar a função <code>pending</code> em qualquer lugar do corpo da especulação, não importa as expectativas, a especulação vai ser marcada como pendente.</p>
<pre>
<code>
describe("Especulações pendentes", function () {

    xit("podem ser declaradas 'xit'", function () {
        expect(true).toBe(false);
    });

    it("pode ser declarado com 'it' mas sem uma função");

    it("pode ser declarado chamando 'pending' no corpo da especulação", function () {
        expect(true).toBe(false);
        pending();
    });
});
</code>
</pre>

<a name="spies__espi_es_"></a><h2>Spies (espiões)<a class="anchorlink" href="#spies__espi_es_"></a></h2>
<p>Jasmine tem duas funções de teste chamadas &#39;spies&#39; (espiões). Um <em>spy</em> (espião) pode rastrear qualquer função, suas chamadas e todos os seus argumentos.. Há comparadores especiais para interagir com os spies. <strong>Esta sintaxe foi alterada para o Jasmine 2.0</strong>. O comparador <code>toHaveBeenCalled</code> vai retornar <code>true</code> se o spy tiver sido chamado. O comparador <code>toHaveBeenCalledWith</code> vai retornar <code>true</code> se a lista de argumentos encontrar qualquer registro chamado com o spy.</p>
<pre>
<code>
describe("Um spy (espião)", function () {
    var foo, bar = null;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            }
        };

        spyOn(foo, 'setBar');

        foo.setBar(123);
        foo.setBar(456, 'another param');
    });

    it("rastreia se o spy foi chamado", function () {
        expect(foo.setBar).toHaveBeenCalled();
    });

    it("rastreia todos os argumentos de chamadas", function () {
        expect(foo.setBar).toHaveBeenCalledWith(123);
        expect(foo.setBar).toHaveBeenCalledWith(456, 'another param');
    });

    it("para toda a execução em uma função", function () {
        expect(bar).toBeNull();
    });
});
</code>
</pre>

<h3>Spies: <code>and.callThrough</code></h3>
<p>Encadeando o spy com <code>and.callThrough</code>, o spy vai continuar rastreando todas as chamadas a ele mas em adição, ele vai delegar a implementação atual.</p>
<pre>
<code>
describe("Um spy, quando configurado para 'call through' (chamar através)", function () {
    var foo, bar, fetchedBar;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            },
            getBar: function () {
                return bar;
            }
        };

        spyOn(foo, 'getBar').and.callThrough();

        foo.setBar(123);
        fetchedBar = foo.getBar();
    });

    it("rastreia se o spy foi chamado", function () {
        expect(foo.getBar).toHaveBeenCalled();
    });

    it("não deve afetar outras funções", function () {
        expect(bar).toEqual(123);
    });

    it("quando chamado retorna o valor requisitado", function () {
        expect(fetchedBar).toEqual(123);
    });
});
</code>
</pre>

<h3>Spies: <code>and.returnValue</code></h3>
<p>Encadeando o spy com <code>and.returnValue</code>, todas as chamadas à função vão retornar um valor específico.</p>
<pre>
<code>
describe("Um spy, quando configurado para 'falsificar' um valor de retorno", function () {
    var foo, bar, fetchedBar;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            },
            getBar: function () {
                return bar;
            }
        };

        spyOn(foo, "getBar").and.returnValue(745);

        foo.setBar(123);
        fetchedBar = foo.getBar();
    });

    it("rastreia se o spy foi chamado", functio () {
        expect(foo.getBar).toHaveBeenCalled();
    });

    it("não deve afetar outras funções", function () {
        expect(bar).toEqual(123);
    });

    it("quando chamado retorna o valor requisitado", function () {
        expect(fetchedBar).toEqual(745);
    })
});
</code>
</pre>

<h3>Spies: <code>and.callFake</code></h3>
<p>Encadeando o spy com <code>and.callFake</code>, todas as chamadas ao spy vão ser delegadas a função fornecida.</p>
<pre>
<code>
describe("Um spy, quando configurado com uma implementação alternativa", function () {
    var foo, bar, fetchedBar;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            },
            getBar: function () {
                return bar;
            }
        };

        spyOn(foo, "getBar").and.callFake(function () {
            return 1001;
        });

        foo.setBar(123);
        fetchedBar = foo.getBar();
    });

    it("rastreia se o spy foi chamado", function () {
        expect(foo.getBar).toHaveBeenCalled();
    });

    it("não deve afetar outras funções", function () {
        expect(bar).toEqual(123);
    });

    it("quando chamado retorna o valor requisitado", function () {
        expect(fetchedBar).toEqual(1001);
    });
});
</code>
</pre>

<h3>Spies: <code>and.throwError</code></h3>
<p>Encadeando o spy com <code>and.throwError</code>, todas as chamadas ao spy vão <code>throw</code> (lançar) o valor especificado como um erro.</p>
<pre>
<code>
describe("Um spy, quando configurado para lançar um erro", function () {
    var foo, bar;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            }
        };

        spyOn(foo, "setBar").and.throwError("quux");
    });

    it("lança o valor", function () {
        expect(function () {
            foo.setBar(123)
        }).toThrowError("quux");
    });
});
</code>
</pre>

<h3>Spies: <code>and.stub</code></h3>
<p>Quando uma chamada estratégica é usada por um spy, o comportamento original <em>stubbing</em> pode ser retornado a qualquer momento com <code>and.stub</code>.</p>
<pre>
<code>
describe("Um spy," function () {
    var foo, bar = null;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            }
        };

        spyOn(foo, 'setBar')and.callThrough();
    });

    it("pode chamar através e então *stub* na mesma especulação", function () {
        foo.setBar(123);
        expect(bar).toEqual(123);

        foo.setBar.and.stub();
        bar = null;

        foo.setBar(123);
        expect(bar).toBe(null);
    });
});
</code>
</pre>

<a name="outras_propriedades_de_rastreamento"></a><h2>Outras Propriedades de Rastreamento<a class="anchorlink" href="#outras_propriedades_de_rastreamento"></a></h2>
<p>Toda chamada a um spy é rastreada e exposta em uma propriedade <code>calls</code>.</p>
<pre>
<code>
describe("Um spy", function () {
    var foo, bar = null;

    beforeEach(function () {
        foo = {
            setBar: function (value) {
                bar = value;
            }
        };

        spyOn(foo, 'setBar');
    });
}); // esse describe fecha originalmente após
    // a demonstração de todos métodos .calls, 
    // mais exatamente no .calls.reset
</code>
</pre>

<p><code>.calls.any()</code>: retorna <code>false</code> se o spy não tiver sido chamado ainda, e <code>true</code> quando a chamada acontece pelo menos uma vez.</p>
<pre>
<code>
it("rastreia se foi chamado alguma vez", function () {
    expect(foo.setBar.calls.any()).toEqual(false);

    foo.setBar();

    expect(foo.setBar.calls.any()).toEqual(true);
});
</code>
</pre>

<p><code>.calls.count()</code>: retorna o número de vezes que o spy foi chamado.</p>
<pre>
<code>
it("rastreia o número de vezes que isso foi chamado", function () {
    expect(foo.setBar.calls.count()).toEqual(0);

    foo.setBar();
    foo.setBar();

    expect(foo.setBar.calls.count()).toEqual(2);
});
</code>
</pre>

<p><code>.calls.argsFor(index)</code>: retorna os argumentos passados chamando pelo seu <code>index</code>.</p>
<pre>
<code>
it("rastreia os argumentos de cada chamada", function () {
    foo.setBar(123);
    foo.setBar(456, "baz");

    expect(foo.setBar.calls.argsFor(0)).toEqual([123]);
    expect(foo.setBar.calls.argsFor(1)).toEqual([456, "baz"]);
});
</code>
</pre>

<p><code>.calls.allArgs()</code>: retorna os argumentos de todas as chamadas.</p>
<pre>
<code>
it("rastreia os argumentos de todas as chamadas", function () {
    foo.setBar(123);
    foo.setBar(456, "baz");

    expect(foo.setBar.calls.allArgs()).toEqual([123],[456, "baz"]);
});
</code>
</pre>

<p><code>.calls.all()</code>: retorna o contexto (o <code>this</code>) e os argumentos passados em todas chamadas.</p>
<pre>
<code>
it("pode fornecer o contexto e argumentos para todas chamadas", function () {
    foo.setBar(123);

    expect(foo.setBar.calls.all()).toEqual([{object: foo, args: [123]}]);
});
</code>
</pre>

<p><code>.calls.mosRecent()</code>: retorna o contexto (o <code>this</code>) e os argumentos para a chamada mais recente.</p>
<pre>
<code>
it("um atalho para a chamada mais recente", function () {
    foo.setBar(123);
    foo.setBar(456, "baz");

    expect(foo.setBar.calls.mostRecent()).toEqual({object: foo, args: [456, "baz"]});
});
</code>
</pre>

<p><code>.calls.first()</code>: retorna o contexto (o <code>this</code>) e os argumentos da primeira chamada.</p>
<pre>
<code>
it("atalho para a primeira chamada", function () {
    foo.setBar(123);
    foo.setBar(456, "baz");

    expect(foo.setBar.calls.first()).toEqual({object: foo, args: [123]});
});
</code>
</pre>

<p><code>.calls.reset()</code>: limpa todo o rastreio do spy.</p>
<pre>
<code>
it("pode ser resetado", function () {
    foo.setBar(123);
    foo.setBar(456, "baz");

    expect(foo.setBar.calls.any()).toBe(true);

    foo.setBar.calls.reset();

    expect(foo.setBar.calls.any()).toBe(false);
});
</code>
</pre>

<h3>Spies: <code>createSpy</code></h3>
<p>Quando não existe uma função para ser especionada, podemos usar <code>jasmine.createSpy</code> para criar um spy. Este spy atua como qualquer outro spy - rastreando chamadas, argumentos e etc. Mas não há uma implementação por trás dele. Spies são objetos JavaScript e pode sem usados desta forma.</p>
<pre>
<code>
describe("Um spy, quando criado manualmente", function () {
    var whatAmI;

    beforeEach(function () {
        whatAmI = jasmine.createSpy('whatAmI');

        whatAmI("I", "am", "a", "spy");
    });

    it("é nomeado, e ajuda no relatório de erro", function () {
        expect(whatAmI.and.identify()).toEqual('whatAmI');
    });

    it("rastreia se o spy foi chamado", function () {
        expect(whatAmI).toHaveBeenCalled();
    });

    it("rastreia o número de chamadas", function () {
        expect(whatAmI.calls.count()).toEqual(1);
    });

    it("rastreia todos os argumentos desta chamada", function () {
        expect(whatAmI).toHaveBeenCalledWith("I", "am", "a", "spy");
    });

    it("permite o acesso a chamada mais recente", function () {
        expect(whatAmI.calls.mostRecent().args[0].toEqual("I"));
    });
});
</code>
</pre>

<h3>Spies: <code>createSpyObj</code></h3>
<p>A fim de criar uma simulação com múltiplos spies, use <code>jasmine.createSpyObj</code> e passe um aray de strings. Isso retorna um objeto que tem uma propriedade para cada string que é um spy.</p>
<pre>
<code>
describe("Múltiplos spies, quando criados manualmente", function () {
    var tape;

    beforeEach(function () {
        tape = jasmine.createSpyObj('tape', ['play', 'pause', 'stop', 'rewind']);

        tape.play();
        tape.pause();
        tape.rewind();
    });

    it("cria spies para cada função requisitada", function () {
        expect(tape.play).toBeDefined();
        expect(tape.pause).toBeDefined();
        expect(tape.stop).toBeDefined();
        expect(tape.rewind).toBeDefined();
    });

    it("rastreia se os spies foram chamados", function () {
        expect(tape.play).toHaveBeenCalled();
        expect(tape.pause).toHaveBeenCalled();
        expect(tape.rewind).toHaveBeenCalled();
        expect(tape.stop).not.toHaveBeenCalled();
    });

    it("rastreia todos os argumentos desta chamada", function () {
        expect(tape.rewind).toHaveBeenCalledWith(0);
    });
});
</code>
</pre>

<h2>Correspondendo tudo com <code>jasmine.any</code></h2>
<p><code>jasmine.any</code> pega um nome de construtor ou de uma &quot;classe&quot; como um valor experado. Ele retorna <code>true</code> se o construtor encontra o construtor do valor real.</p>
<pre>
<code>
describe("jasmine.any", function () {
    it("encontra qualquer valor", function () {
        expect({}).toEqual(jasmine.any(Object));
        expect(12).toEqual(jasmine.any(Number));
    });

    describe("quando usado com um spy", function () {
        it("é útil para comparar argumentos", function () {
            var foo = jasmine.createSpy('foo');
            foo(12, function () {
                return true;
            });

            expect(foo).toHaveBeenCalledWidth(jasmine.any(Number), jasmine.any(function));
        });
    });
});
</code>
</pre>

<h2>Combinação parcial com <code>jasmine.objectContaining</code></h2>
<p><code>jasmine.objectContaining</code> é para quando uma expectativa somente importa sobre certos pares chave/valor serem verdadeiros.</p>
<pre>
<code>
describe("jasmine.objectContaining", function () {
    var foo;

    beforeEach(function () {
        foo = {
            a: 1,
            b: 2,
            bar: "baz"
        };
    });

    it("encontra objetos com os pares chave/valor experado", function () {
        expect(foo).toEqual(jasmine.objectContaining({
            bar: "baz"
        }));
        expect(foo).not.toEqual(jasmine.objectContaining({
            c: 37
        }));
    });

    describe("quando usado com um spy", function () {
        it("é útil para comparar argumentos", function () {
            var callback = jasmine.createSpy('callback');

            callback({
                bar: "baz"
            });

            expect(callback).toHaveBeenCalledWith(jasmine.objectContaining({
                bar: "baz"
            }));
            expect(callback).not.toHaveBeenCalledWith(jasmine.objectContaining({
                c: 37
            }));
        });
    });
});
</code>
</pre>

<a name="simulando_fun__es_timeout_do_javascript"></a><h2>Simulando Funções Timeout do JavaScript<a class="anchorlink" href="#simulando_fun__es_timeout_do_javascript"></a></h2>
<p><strong>Esta sintaxe mudou no Jasmine 2.0</strong>. O <em>Jasmine Clock</em> está disponível para um conjunto de testes que precisam da habilidade de usar callbacks <code>setTimeout</code> ou <code>setInterval</code>. Isto torna os callbacks síncronos, executando as funções registradas somente se o tempo estiver passando. Isto torna o código relacionado ao temporizador muito mais fácil de ser testado.</p>
<p>Ele é instalado com a chamada <code>jasmine.clock().install</code> em uma especulação ou conjunto que precisa de chamar funções temporizadoras.</p>
<p>Assegure-se de desinstalar o clock depois que você tiver feito terminado para restaurar o temporizador original das funções.</p>
<p>Chamadas para qualquer callback registrado é disparada quando o relógio é iniciado por via da função <code>jasmine.clock().tick</code>, que pega o número em milisegundos.</p>
<pre>
<code>
describe("Iniciando manualmente o relógio do Jasmine", function () {
    var timeCallback;

    beforeEach(function () {
        timerCallback = jasmine.createSpy("timerCallback");
        jasmine.clock().install();
    });

    afterEach(function () {
        jasmine.clock().uninstall();
    });

    it("faz com que o timeout seja chamado síncronamente", function () {
        setTimeout(function () {
            timerCallback();
        }, 100);

        expect(timerCallback).not.toHaveBeenCalled();

        jasmine.clock().tick(101);

        expect(timerCallback).toHaveBeenCalled();
    });

    it("faz com que um intervalo seja chamado síncronamente", function () {
        setInterval(function () {
            timerCallback();
        }, 100);

        expect(timerCallback).not.toHaveBeenCalled();

        jasmine.clock().tick(101);
        expect(timerCallback.calls.count()).toEqual(1);

        jasmine.clock().tick(50);
        expect(timerCallback.calls.count()).toEqual(1);

        jasmine.clock().tick(50);
        expect(timerCallback.calls.count()).toEqual(2);
    });
});
</code>
</pre>

<a name="suporte_ass_ncrono"></a><h2>Suporte Assíncrono<a class="anchorlink" href="#suporte_ass_ncrono"></a></h2>
<p><strong>Esta sintaxe mudou no Jasmine 2.0</strong>: O Jasmine também suporta rodar especulações que necessitam de operações de testes assíncronos.</p>
<p>Chamadas à <code>beforeEach</code>, <code>it</code> e <code>afterEach</code> podem ter um simples argumento opcional que deve ser chamado quando o trabalho assíncrono está completo.</p>
<p>Essa especulação não vai iniciar até que a função <code>done</code> seja chamada pela chamada <code>beforeEach</code>. E esta especulação não vai estar completa até que <code>done</code> seja chamado.</p>
<pre class="prettyprint"><code>
<p>describe(&quot;Especulações Assíncronas&quot;, function () {
    var value;</p>
beforeEach(function () {
    setTimeout(function () {
        value = 0;
        done();
    }, 1);
});

it(&quot;deve suportar a execução assíncrona dos testes - preparação e expectativas&quot;, function (done) {
    value++;
    expect(value).toBeGreaterThan(0);
    done();
});
<p>});</p></code></pre>
<a name="downloads"></a><h2>Downloads<a class="anchorlink" href="#downloads"></a></h2>
<ul class="list">
<li>O <a href="https://github.com/pivotal/jasmine/tree/master/dist">lançamento independente</a> é para página do navegador, ou console de projetos.</li>
<li>O <a href="http://github.com/pivotal/jasmine-gem">Jasmine Ruby Gem</a> é para Rails, Ruby, ou desenvolvimento amigável ao Ruby.</li>
<li><a href="http://github.com/pivotal/jasmine/wiki">Outros ambientes</a> também são suportados.</li>
</ul>
<a name="suporte"></a><h2>Suporte<a class="anchorlink" href="#suporte"></a></h2>
<ul class="list">
<li><a href="http://groups.google.com/group/jasmine-js">Lista de Email</a> no Google Groups - uma grande primeira parada para fazer perguntas, propor coisas, ou discutir <em>pull requests</em></li>
<li><a href="http://github.com/pivotal/jasmine/issues">Relate questões</a> no Github.</li>
<li>O <a href="http://www.pivotaltracker.com/projects/10606">Backlog</a> no <a href="http://www.pivotaltracker.com/">Pivotal Tracker</a></li>
<li>Siga <a href="http://twitter.com/jasminebdd">@JasmineBDD</a> no Twitter</li>
</ul>
<a name="obrigado"></a><h2>Obrigado<a class="anchorlink" href="#obrigado"></a></h2>
<p><em>Documentação inspirada por <a href="http://twitter.com/mjackson">@mjackson</a> na Fluent Summit em 2012</em>.</p>


</body>
</html>
